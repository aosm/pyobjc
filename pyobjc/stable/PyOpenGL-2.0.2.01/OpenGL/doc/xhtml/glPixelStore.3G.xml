<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html
	xmlns="http://www.w3.org/1999/xhtml"
	xmlns:mml="http://www.w3.org/1998/Math/MathML"
><head><title>glPixelStore</title><link rel="stylesheet" href="style.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.59.1"/><link rel="home" href="index.xml" title="PyOpenGL 2.0.1.09 Man Pages"/><link rel="up" href="reference-GL.xml" title="GL"/><link rel="previous" href="glPixelMap.3G.xml" title="glPixelMap"/><link rel="next" href="glPixelTransfer.3G.xml" title="glPixelTransfer"/></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">glPixelStore</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="glPixelMap.3G.xml">Prev</a> </td><th width="60%" align="center">GL</th><td width="20%" align="right"> <a accesskey="n" href="glPixelTransfer.3G.xml">Next</a></td></tr></table><hr/></div><div class="refentry" lang="en"><a name="glPixelStore.3G"/><div class="titlepage"/><div class="refnamediv"><a name="glPixelStore.3G-name"/><h2>Name</h2><p>glPixelStoref, glPixelStorei &#8212; set pixel storage modes</p></div><div class="refsynopsisdiv"><a name="glPixelStore.3G-c_spec"/><h2>C Specification</h2><table class="funcprototype" border="0" cellpadding="0" cellspacing="0"><tr><td valign="top"><code>void <tt>glPixelStoref</tt></code></td><td valign="top"><code>(</code></td><td valign="top"><code>GLenum <i><tt>pname</tt></i>, GLfloat <i><tt>param</tt></i>);</code></td></tr><tr><td valign="top"><code>void <tt>glPixelStorei</tt></code></td><td valign="top"><code>(</code></td><td valign="top"><code>GLenum <i><tt>pname</tt></i>, GLint <i><tt>param</tt></i>);</code></td></tr></table></div><div class="refsynopsisdiv"><a name="glPixelStore.3G-python_spec"/><h2>Python Specification</h2><table class="funcprototype" border="0" cellpadding="0" cellspacing="0"><tr><td valign="top"><code><tt>glPixelStoref</tt></code></td><td valign="top"><code>(</code></td><td valign="top"><code><i><tt>pname</tt></i>, <i><tt>param</tt></i>) &#8594; <tt>None</tt></code></td></tr><tr><td valign="top"><code><tt>glPixelStorei</tt></code></td><td valign="top"><code>(</code></td><td valign="top"><code><i><tt>pname</tt></i>, <i><tt>param</tt></i>) &#8594; <tt>None</tt></code></td></tr></table></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-parameters"/><h2>Parameters</h2><div class="variablelist"><dl><dt><span class="term"><i><tt>pname</tt></i></span></dt><dd>
						Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into
						memory: <tt>GL_PACK_SWAP_BYTES</tt>, <tt>GL_PACK_LSB_FIRST</tt>,
						<tt>GL_PACK_ROW_LENGTH</tt>, <tt>GL_PACK_IMAGE_HEIGHT</tt>,
						<tt>GL_PACK_SKIP_PIXELS</tt>, <tt>GL_PACK_SKIP_ROWS</tt>,
						<tt>GL_PACK_SKIP_IMAGES</tt>, and <tt>GL_PACK_ALIGNMENT</tt>. Six more affect the
						unpacking of pixel data <i><tt>from</tt></i> memory: <tt>GL_UNPACK_SWAP_BYTES</tt>,
						<tt>GL_UNPACK_LSB_FIRST</tt>, <tt>GL_UNPACK_ROW_LENGTH</tt>,
						<tt>GL_UNPACK_IMAGE_HEIGHT</tt>, <tt>GL_UNPACK_SKIP_PIXELS</tt>,
						<tt>GL_UNPACK_SKIP_ROWS</tt>, <tt>GL_UNPACK_SKIP_IMAGES</tt>, and
						<tt>GL_UNPACK_ALIGNMENT</tt>.
					</dd><dt><span class="term"><i><tt>param</tt></i></span></dt><dd>
						Specifies the value that <i><tt>pname</tt></i> is set to.
					</dd></dl></div></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-description"/><h2>Description</h2><p>
			<tt>glPixelStore</tt> sets pixel storage modes that affect the operation of subsequent
			<a href="glDrawPixels.3G.xml"><tt>glDrawPixels</tt></a> and <a href="glReadPixels.3G.xml"><tt>glReadPixels</tt></a> as well
			as the unpacking of polygon stipple patterns (see <a href="glPolygonStipple.3G.xml">glPolygonStipple</a>), bitmaps (see <a href="glBitmap.3G.xml">glBitmap</a>), texture patterns (see <a href="glTexImage1D.3G.xml">glTexImage1D</a>, <a href="glTexImage2D.3G.xml"><tt>glTexImage2D</tt></a>, <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a>, <a href="glTexSubImage1D.3G.xml"><tt>glTexSubImage1D</tt></a>, <a href="glTexSubImage2D.3G.xml"><tt>glTexSubImage2D</tt></a>, <a href="glTexSubImage3D.3G.xml"><tt>glTexSubImage3D</tt></a>).
			Additionally, if the <tt>GL_ARB_imaging</tt> extension is supported, pixle storage modes affect convlution
			filters (see <a href="glConvolutionFilter1D.3G.xml">glConvolutionFilter1D</a>, <a href="glConvolutionFilter2D.3G.xml"><tt>glConvolutionFilter2D</tt></a>, and <a href="glSeparableFilter2D.3G.xml"><tt>glSeparableFilter2D</tt></a>, color table (see <a href="glColorTable.3G.xml">glColorTable</a>, and <a href="glColorSubTable.3G.xml"><tt>glColorSubTable</tt></a>, and unpacking histogram (See
			<a href="glHistogram.3G.xml">glHistogram</a>), and minmax (See <a href="glMinmax.3G.xml"><tt>glMinmax</tt></a>) data.
		</p><p>
			<i><tt>pname</tt></i> is a symbolic constant indicating the parameter to be set, and
			<i><tt>param</tt></i> is the new value. Six of the twelve storage parameters affect how pixel data is returned
			to client memory. They are as follows:
		</p><div class="variablelist"><dl><dt><span class="term"><tt>GL_PACK_SWAP_BYTES</tt></span></dt><dd>
						If true, byte ordering for multibyte color components, depth components, color indices, or stencil indices
						is reversed. That is, if a four-byte component consists of bytes <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>0</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>1</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>2</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>3</mml:mn>
								</mml:msub>
							</mml:math>, it is stored in memory as <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>3</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>2</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>1</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>0</mml:mn>
								</mml:msub>
							</mml:math> if <tt>GL_PACK_SWAP_BYTES</tt> is true.
						<tt>GL_PACK_SWAP_BYTES</tt> has no effect on the memory order of components within a pixel,
						only on the order of bytes within components or indices. For example, the three components of a
						<tt>GL_RGB</tt> pixel are always stored with red first, green second, and blue third,
						regardless of the value of <tt>GL_PACK_SWAP_BYTES</tt>.
					</dd><dt><span class="term"><tt>GL_PACK_LSB_FIRST</tt></span></dt><dd>
						If true, bits are ordered within a byte from least significant to most significant; otherwise, the first
						bit in each byte is the most significant one. This parameter is significant for bitmap data only.
					</dd><dt><span class="term"><tt>GL_PACK_ROW_LENGTH</tt></span></dt><dd><p>
						If greater than 0, <tt>GL_PACK_ROW_LENGTH</tt> defines the number of pixels in a row. If the
						first pixel of a row is placed at location <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>p</mml:mi>
							</mml:math> in memory, then the location of the first pixel of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mo>{</mml:mo>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>n</mml:mi>
													<mml:mi>l</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mrow>
														<mml:mfrac>
															<mml:mi>a</mml:mi>
															<mml:mi>s</mml:mi>
														</mml:mfrac>
														<mml:mrow>
															<mml:mo>&#8968;</mml:mo>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>s</mml:mi>
																	<mml:mi>n</mml:mi>
																	<mml:mi>l</mml:mi>
																</mml:mrow>
																<mml:mi>a</mml:mi>
															</mml:mfrac>
															<mml:mo>&#8969;</mml:mo>
														</mml:mrow>
													</mml:mrow>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&#8805;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&lt;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in a pixel, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>l</mml:mi>
							</mml:math> is the number of pixels in a row (<tt>GL_PACK_ROW_LENGTH</tt> if it is
						greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>width</mml:mi>
							</mml:math> argument to the pixel routine otherwise), <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>a</mml:mi>
							</mml:math> is the value of <tt>GL_PACK_ALIGNMENT</tt>, and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>s</mml:mi>
							</mml:math> is the size, in bytes, of a single component (if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>&lt;</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>, then it is as if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>). In the case of 1-bit values, the location of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mn>8</mml:mn>
									<mml:mi>a</mml:mi>
									<mml:mrow>
										<mml:mo>&#8968;</mml:mo>
										<mml:mfrac>
											<mml:mrow>
												<mml:mi>n</mml:mi>
												<mml:mi>l</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>8</mml:mn>
												<mml:mi>a</mml:mi>
											</mml:mrow>
										</mml:mfrac>
										<mml:mo>&#8969;</mml:mo>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices.
					</p><p>
						The word <i><tt>component</tt></i> in this description refers to the nonindex values red, green,
						blue, alpha, and depth. Storage <tt>GL_RGB</tt>, for example, has three components per pixel:
						first red, then green, and finally blue.
					</p></dd><dt><span class="term"><tt>GL_PACK_IMAGE_HEIGHT</tt></span></dt><dd><p>
						If greater than 0, <tt>GL_PACK_IMAGE_HEIGHT</tt> defines the number of pixels in an image
						three-dimensional texture volume. Where ``image'' is defined by all pixels sharing the same third dimension
						index. If the first pixel of a row is placed at location <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>p</mml:mi>
							</mml:math> in memory, then the location of the first pixel of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mo>{</mml:mo>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>n</mml:mi>
													<mml:mi>l</mml:mi>
													<mml:mi>h</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mrow>
														<mml:mfrac>
															<mml:mi>a</mml:mi>
															<mml:mi>s</mml:mi>
														</mml:mfrac>
														<mml:mrow>
															<mml:mo>&#8968;</mml:mo>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>s</mml:mi>
																	<mml:mi>n</mml:mi>
																	<mml:mi>l</mml:mi>
																	<mml:mi>h</mml:mi>
																</mml:mrow>
																<mml:mi>a</mml:mi>
															</mml:mfrac>
															<mml:mo>&#8969;</mml:mo>
														</mml:mrow>
													</mml:mrow>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&#8805;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&lt;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in a pixel, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>l</mml:mi>
							</mml:math> is the number of pixels in a row (<tt>GL_PACK_ROW_LENGTH</tt> if it is
						greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>width</mml:mi>
							</mml:math> argument to <tt>glTexImage3d</tt> otherwise),
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>h</mml:mi>
							</mml:math> is the number of rows in a pixel image (<tt>GL_PACK_IMAGE_HEIGHT</tt> if it
						is greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>height</mml:mi>
							</mml:math> arguemnt to the <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a> routine otherwise),
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>a</mml:mi>
							</mml:math> is the value of <tt>GL_PACK_ALIGNMENT</tt>, and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>s</mml:mi>
							</mml:math> is the size, in bytes, of a single component (if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>&lt;</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>, then it is as if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>).
					</p><p>
						The word <i><tt>component</tt></i> in this description refers to the nonindex values red, green,
						blue, alpha, and depth. Storage <tt>GL_RGB</tt>, for example, has three components per pixel:
						first red, then green, and finally blue.
					</p></dd><dt><span class="term"><tt>GL_PACK_SKIP_PIXELS</tt>, <tt>GL_PACK_SKIP_ROWS</tt>, and
				<tt>GL_PACK_SKIP_IMAGES</tt></span></dt><dd>
						These values are provided as a convenience to the programmer; they provide no functionality that cannot be
						duplicated simply by incrementing the pointer passed to <a href="glReadPixels.3G.xml"><tt>glReadPixels</tt></a>. Setting <tt>GL_PACK_SKIP_PIXELS</tt> to
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>i</mml:mi>
							</mml:math> is equivalent to incrementing the pointer by <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>i</mml:mi>
									<mml:mi>n</mml:mi>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in each pixel. Setting
						<tt>GL_PACK_SKIP_ROWS</tt> to <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>j</mml:mi>
							</mml:math> is equivalent to incrementing the pointer by <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>j</mml:mi>
									<mml:mi>m</mml:mi>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>m</mml:mi>
							</mml:math> is the number of components or indices per row, as just computed in the
						<tt>GL_PACK_ROW_LENGTH</tt> section. Setting <tt>GL_PACK_SKIP_IMAGES</tt> to
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>k</mml:mi>
							</mml:math> is equivalent to incrementing the pointer by <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mi>p</mml:mi>
								</mml:mrow>
							</mml:math>, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>p</mml:mi>
							</mml:math> is the number of components or indices per image, as computed in the
						<tt>GL_PACK_IMAGE_HEIGHT</tt> section.
					</dd><dt><span class="term"><tt>GL_PACK_ALIGNMENT</tt></span></dt><dd>
						Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1
						(byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on
						double-word boundaries).
					</dd></dl></div><p>
			The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are
			significant for <a href="glDrawPixels.3G.xml"><tt>glDrawPixels</tt></a>, <a href="glTexImage1D.3G.xml"><tt>glTexImage1D</tt></a>, <a href="glTexImage2D.3G.xml"><tt>glTexImage2D</tt></a>, <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a>, <a href="glTexSubImage1D.3G.xml"><tt>glTexSubImage1D</tt></a>, <a href="glTexSubImage2D.3G.xml"><tt>glTexSubImage2D</tt></a>, <a href="glTexSubImage3D.3G.xml"><tt>glTexSubImage3D</tt></a>, <a href="glBitmap.3G.xml"><tt>glBitmap</tt></a>, and <a href="glPolygonStipple.3G.xml"><tt>glPolygonStipple</tt></a>.
		</p><p>
			Additionally, if the <tt>GL_ARB_imaging</tt> extension is supported, <a href="glColorTable.3G.xml"><tt>glColorTable</tt></a>, <a href="glColorSubTable.3G.xml"><tt>glColorSubTable</tt></a>, <a href="glConvolutionFilter1D.3G.xml"><tt>glConvolutionFilter1D</tt></a>, <a href="glConvolutionFilter2D.3G.xml"><tt>glConvolutionFilter2D</tt></a>,
			and <a href="glSeparableFilter2D.3G.xml"><tt>glSeparableFilter2D</tt></a>. They are as follows:
		</p><div class="variablelist"><dl><dt><span class="term"><tt>GL_UNPACK_SWAP_BYTES</tt></span></dt><dd>
						If true, byte ordering for multibyte color components, depth components, color indices, or stencil indices
						is reversed. That is, if a four-byte component consists of bytes <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>0</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>1</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>2</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>3</mml:mn>
								</mml:msub>
							</mml:math>, it is taken from memory as <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>3</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>2</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>1</mml:mn>
								</mml:msub>
							</mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:msub>
									<mml:mi>b</mml:mi>
									<mml:mn>0</mml:mn>
								</mml:msub>
							</mml:math> if <tt>GL_UNPACK_SWAP_BYTES</tt> is true.
						<tt>GL_UNPACK_SWAP_BYTES</tt> has no effect on the memory order of components within a pixel,
						only on the order of bytes within components or indices. For example, the three components of a
						<tt>GL_RGB</tt> pixel are always stored with red first, green second, and blue third,
						regardless of the value of <tt>GL_UNPACK_SWAP_BYTES</tt>.
					</dd><dt><span class="term"><tt>GL_UNPACK_LSB_FIRST</tt></span></dt><dd>
						If true, bits are ordered within a byte from least significant to most significant; otherwise, the first
						bit in each byte is the most significant one. This is relevant only for bitmap data.
					</dd><dt><span class="term"><tt>GL_UNPACK_ROW_LENGTH</tt></span></dt><dd><p>
						If greater than 0, <tt>GL_UNPACK_ROW_LENGTH</tt> defines the number of pixels in a row. If the
						first pixel of a row is placed at location <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>p</mml:mi>
							</mml:math> in memory, then the location of the first pixel of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mo>{</mml:mo>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>n</mml:mi>
													<mml:mi>l</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mrow>
														<mml:mfrac>
															<mml:mi>a</mml:mi>
															<mml:mi>s</mml:mi>
														</mml:mfrac>
														<mml:mrow>
															<mml:mo>&#8968;</mml:mo>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>s</mml:mi>
																	<mml:mi>n</mml:mi>
																	<mml:mi>l</mml:mi>
																</mml:mrow>
																<mml:mi>a</mml:mi>
															</mml:mfrac>
															<mml:mo>&#8969;</mml:mo>
														</mml:mrow>
													</mml:mrow>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&#8805;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&lt;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in a pixel, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>l</mml:mi>
							</mml:math> is the number of pixels in a row (<tt>GL_UNPACK_ROW_LENGTH</tt> if it is
						greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>width</mml:mi>
							</mml:math> argument to the pixel routine otherwise), <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>a</mml:mi>
							</mml:math> is the value of <tt>GL_UNPACK_ALIGNMENT</tt>, and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>s</mml:mi>
							</mml:math> is the size, in bytes, of a single component (if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>&lt;</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>, then it is as if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>). In the case of 1-bit values, the location of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mn>8</mml:mn>
									<mml:mi>a</mml:mi>
									<mml:mrow>
										<mml:mo>&#8968;</mml:mo>
										<mml:mfrac>
											<mml:mrow>
												<mml:mi>n</mml:mi>
												<mml:mi>l</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>8</mml:mn>
												<mml:mi>a</mml:mi>
											</mml:mrow>
										</mml:mfrac>
										<mml:mo>&#8969;</mml:mo>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices.
					</p><p>
						The word <i><tt>component</tt></i> in this description refers to the nonindex values red, green,
						blue, alpha, and depth. Storage <tt>GL_RGB</tt>, for example, has three components per pixel:
						first red, then green, and finally blue.
					</p></dd><dt><span class="term"><tt>GL_UNPACK_IMAGE_HEIGHT</tt></span></dt><dd><p>
						If greater than 0, <tt>GL_UNPACK_IMAGE_HEIGHT</tt> defines the number of pixels in an image of
						a three-dimensional texture volume. Where ``image'' is defined by all pixel sharing the same third
						dimension index. If the first pixel of a row is placed at location <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>p</mml:mi>
							</mml:math> in memory, then the location of the first pixel of the next row is obtained by skipping
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>k</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mo>{</mml:mo>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>n</mml:mi>
													<mml:mi>l</mml:mi>
													<mml:mi>h</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mrow>
														<mml:mfrac>
															<mml:mi>a</mml:mi>
															<mml:mi>s</mml:mi>
														</mml:mfrac>
														<mml:mrow>
															<mml:mo>&#8968;</mml:mo>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>s</mml:mi>
																	<mml:mi>n</mml:mi>
																	<mml:mi>l</mml:mi>
																	<mml:mi>h</mml:mi>
																</mml:mrow>
																<mml:mi>a</mml:mi>
															</mml:mfrac>
															<mml:mo>&#8969;</mml:mo>
														</mml:mrow>
													</mml:mrow>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
										<mml:mtable>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&#8805;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
											<mml:mtr>
												<mml:mtd>
													<mml:mi>s</mml:mi>
													<mml:mo>&lt;</mml:mo>
													<mml:mi>a</mml:mi>
												</mml:mtd>
											</mml:mtr>
										</mml:mtable>
									</mml:mrow>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in a pixel, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>l</mml:mi>
							</mml:math> is the number of pixels in a row (<tt>GL_UNPACK_ROW_LENGTH</tt> if it is
						greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>width</mml:mi>
							</mml:math> argument to <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a> otherwise),
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>h</mml:mi>
							</mml:math> is the number of rows in an image (<tt>GL_UNPACK_IMAGE_HEIGHT</tt> if it is
						greater than 0, the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>height</mml:mi>
							</mml:math> argument to <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a> otherwise),
						<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>a</mml:mi>
							</mml:math> is the value of <tt>GL_UNPACK_ALIGNMENT</tt>, and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>s</mml:mi>
							</mml:math> is the size, in bytes, of a single component (if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>&lt;</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>, then it is as if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>a</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:mi>s</mml:mi>
								</mml:mrow>
							</mml:math>).
					</p><p>
						The word <i><tt>component</tt></i> in this description refers to the nonindex values red, green,
						blue, alpha, and depth. Storage <tt>GL_RGB</tt>, for example, has three components per pixel:
						first red, then green, and finally blue.
					</p></dd><dt><span class="term"><tt>GL_UNPACK_SKIP_PIXELS</tt> and <tt>GL_UNPACK_SKIP_ROWS</tt></span></dt><dd>
						These values are provided as a convenience to the programmer; they provide no functionality that cannot be
						duplicated by incrementing the pointer passed to <a href="glDrawPixels.3G.xml"><tt>glDrawPixels</tt></a>,
						<a href="glTexImage1D.3G.xml"><tt>glTexImage1D</tt></a>, <a href="glTexImage2D.3G.xml"><tt>glTexImage2D</tt></a>, <a href="glTexSubImage1D.3G.xml"><tt>glTexSubImage1D</tt></a>,
						<a href="glTexSubImage2D.3G.xml"><tt>glTexSubImage2D</tt></a>, <a href="glBitmap.3G.xml"><tt>glBitmap</tt></a>, or <a href="glPolygonStipple.3G.xml"><tt>glPolygonStipple</tt></a>.
						Setting <tt>GL_UNPACK_SKIP_PIXELS</tt> to <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>i</mml:mi>
							</mml:math> is equivalent to incrementing the pointer by <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>i</mml:mi>
									<mml:mi>n</mml:mi>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>n</mml:mi>
							</mml:math> is the number of components or indices in each pixel. Setting
						<tt>GL_UNPACK_SKIP_ROWS</tt> to <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>j</mml:mi>
							</mml:math> is equivalent to incrementing the pointer by <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mrow>
									<mml:mi>j</mml:mi>
									<mml:mi>k</mml:mi>
								</mml:mrow>
							</mml:math> components or indices, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" overflow="scroll">
								<mml:mi>k</mml:mi>
							</mml:math> is the number of components or indices per row, as just computed in the
						<tt>GL_UNPACK_ROW_LENGTH</tt> section.
					</dd><dt><span class="term"><tt>GL_UNPACK_ALIGNMENT</tt></span></dt><dd>
						Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1
						(byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on
						double-word boundaries).
					</dd></dl></div><p>
			The following table gives the type, initial value, and range of valid values for each storage parameter that can be set
			with <tt>glPixelStore</tt>.
		</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td><i><tt>pname</tt></i></td><td align="center"><span class="bold"><b>Type</b></span></td><td align="center"><span class="bold"><b>Initial Value</b></span></td><td align="center"><span class="bold"><b>Valid Range</b></span></td></tr><tr><td><tt>GL_PACK_SWAP_BYTES</tt></td><td align="center">boolean</td><td align="center">false</td><td align="center">true or false</td></tr><tr><td><tt>GL_PACK_LSB_FIRST</tt></td><td align="center">boolean</td><td align="center">false</td><td align="center">true or false</td></tr><tr><td><tt>GL_PACK_ROW_LENGTH</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_PACK_IMAGE_HEIGHT</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0, &#8734;)</td></tr><tr><td><tt>GL_PACK_SKIP_ROWS</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_PACK_SKIP_PIXELS</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_PACK_SKIP_IMAGES</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_PACK_ALIGNMENT</tt></td><td align="center">integer</td><td align="center">4</td><td align="center">1, 2, 4, or 8</td></tr><tr><td><tt>GL_UNPACK_SWAP_BYTES</tt></td><td align="center">boolean</td><td align="center">false</td><td align="center">true or false</td></tr><tr><td><tt>GL_UNPACK_LSB_FIRST</tt></td><td align="center">boolean</td><td align="center">false</td><td align="center">true or false</td></tr><tr><td><tt>GL_UNPACK_ROW_LENGTH</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_UNPACK_IMAGE_HEIGHT</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_UNPACK_SKIP_ROWS</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_UNPACK_SKIP_PIXELS</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_UNPACK_SKIP_IMAGES</tt></td><td align="center">integer</td><td align="center">0</td><td align="center">[0,&#8734;)</td></tr><tr><td><tt>GL_UNPACK_ALIGNMENT</tt></td><td align="center">integer</td><td align="center">4</td><td align="center">1, 2, 4, or 8</td></tr></tbody></table></div><p>
			<tt>glPixelStoref</tt> can be used to set any pixel store parameter. If the parameter type is boolean, then
			if <i><tt>param</tt></i> is 0, the parameter is false; otherwise it is set to true. If
			<i><tt>pname</tt></i> is a integer type parameter, <i><tt>param</tt></i> is rounded to the nearest
			integer.
		</p><p>
			Likewise, <tt>glPixelStorei</tt> can also be used to set any of the pixel store parameters. Boolean
			parameters are set to false if <i><tt>param</tt></i> is 0 and true otherwise.
		</p></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-notes"/><h2>Notes</h2><p>
			The pixel storage modes in effect when <a href="glDrawPixels.3G.xml"><tt>glDrawPixels</tt></a>, <a href="glReadPixels.3G.xml"><tt>glReadPixels</tt></a>, <a href="glTexImage1D.3G.xml"><tt>glTexImage1D</tt></a>, <a href="glTexImage2D.3G.xml"><tt>glTexImage2D</tt></a>, <a href="glTexImage3D.3G.xml"><tt>glTexImage3D</tt></a>, <a href="glTexSubImage1D.3G.xml"><tt>glTexSubImage1D</tt></a>, <a href="glTexSubImage2D.3G.xml"><tt>glTexSubImage2D</tt></a>, <a href="glTexSubImage3D.3G.xml"><tt>glTexSubImage3D</tt></a>, <a href="glBitmap.3G.xml"><tt>glBitmap</tt></a>, or <a href="glPolygonStipple.3G.xml"><tt>glPolygonStipple</tt></a> is placed in a display list control the interpretation of memory data.
			Likewise, if the <tt>GL_ARB_imaging</tt> extension is supported, the pixel storage modes in effect when
			<a href="glColorTable.3G.xml"><tt>glColorTable</tt></a>, <a href="glColorSubTable.3G.xml"><tt>glColorSubTable</tt></a>,
			<a href="glConvolutionFilter1D.3G.xml"><tt>glConvolutionFilter1D</tt></a>, <a href="glConvolutionFilter2D.3G.xml"><tt>glConvolutionFilter2D</tt></a>, of <a href="glSeparableFilter2D.3G.xml"><tt>glSeparableFilter2D</tt></a>
			is placed in a display list control the intrepretation of memory data. The pixel storage modes in effect when a display
			list is executed are not significant.
		</p><p>
			Pixel storage modes are client state and must be pushed and restored using
		</p><p>
			<a href="glPushClientAttrib.3G.xml"><tt>glPushClientAttrib</tt></a> and <a href="glPushClientAttrib.3G.xml"><tt>glPopClientAttrib</tt></a>.
		</p></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-errors"/><h2>Errors</h2><p>
			<tt>GL_INVALID_ENUM</tt> is generated if <i><tt>pname</tt></i> is not an accepted value.
		</p><p>
			<tt>GL_INVALID_VALUE</tt> is generated if a negative row length, pixel skip, or row skip value is
			specified, or if alignment is specified as other than 1, 2, 4, or 8.
		</p><p>
			<tt>GL_INVALID_OPERATION</tt> is generated if <tt>glPixelStore</tt> is
			executed between the execution of <a href="glBegin.3G.xml"><tt>glBegin</tt></a> and the corresponding execution of
			<a href="glBegin.3G.xml"><tt>glEnd</tt></a>.
		</p></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-associated_gets"/><h2>Associated Gets</h2><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_SWAP_BYTES</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_LSB_FIRST</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_ROW_LENGTH</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_IMAGE_HEIGHT</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_SKIP_ROWS</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_SKIP_PIXELS</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_SKIP_IMAGES</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_PACK_ALIGNMENT</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_SWAP_BYTES</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_LSB_FIRST</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_ROW_LENGTH</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_IMAGE_HEIGHT</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_SKIP_ROWS</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_SKIP_PIXELS</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_SKIP_IMAGES</tt>
		</p><p>
			<tt>glGet</tt> with argument <tt>GL_UNPACK_ALIGNMENT</tt>
		</p></div><div class="refsect1" lang="en"><a name="glPixelStore.3G-see_also"/><h2>See Also</h2><p>
			<span class="simplelist"><a href="glBitmap.3G.xml">glBitmap</a>, <a href="glColorTable.3G.xml">glColorTable</a>, <a href="glColorSubTable.3G.xml">glColorSubTable</a>, <a href="glConvolutionFilter1D.3G.xml">glConvolutionFilter1D</a>, <a href="glConvolutionFilter2D.3G.xml">glConvolutionFilter2D</a>, <a href="glSeparableFilter2D.3G.xml">glSeparableFilter2D</a>, <a href="glDrawPixels.3G.xml">glDrawPixels</a>, <a href="glHistogram.3G.xml">glHistogram</a>, <a href="glMinmax.3G.xml">glMinmax</a>, <a href="glPixelMap.3G.xml">glPixelMap</a>, <a href="glPixelTransfer.3G.xml">glPixelTransfer</a>, <a href="glPixelZoom.3G.xml">glPixelZoom</a>, <a href="glPolygonStipple.3G.xml">glPolygonStipple</a>, <a href="glPushClientAttrib.3G.xml">glPushClientAttrib</a>, <a href="glReadPixels.3G.xml">glReadPixels</a>, <a href="glTexImage1D.3G.xml">glTexImage1D</a>, <a href="glTexImage2D.3G.xml">glTexImage2D</a>, <a href="glTexImage3D.3G.xml">glTexImage3D</a>, <a href="glTexSubImage1D.3G.xml">glTexSubImage1D</a>, <a href="glTexSubImage2D.3G.xml">glTexSubImage2D</a>, <a href="glTexSubImage3D.3G.xml">glTexSubImage3D</a></span>
		</p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="glPixelMap.3G.xml">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="reference-GL.xml">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="glPixelTransfer.3G.xml">Next</a></td></tr><tr><td width="40%" align="left" valign="top">glPixelMap </td><td width="20%" align="center"><a accesskey="h" href="index.xml">Home</a></td><td width="40%" align="right" valign="top"> glPixelTransfer</td></tr></table></div></body></html>